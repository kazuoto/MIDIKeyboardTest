<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AudioWorklet Multi-Sample Piano-ish</title>
</head>
<body>
  <h1>AudioWorkletã§è¤‡æ•°ãƒ”ã‚¢ãƒã‚µãƒ³ãƒ—ãƒ«å†ç”Ÿã«ã‚ƒ(ãªã‚“ã¡ã‚ƒã£ã¦ç‰ˆ)</h1>
  <button id="startBtn">ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªï¼†MIDIé–‹å§‹ã«ã‚ƒ</button>

  <script>
    /* 
      â˜…â˜…â˜… Salamander Piano ã®ä¸€éƒ¨ã‚­ãƒ¼ã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ä½¿ã†ã«ã‚ƒ â˜…â˜…â˜…

      ä¸‹ã¯ã€ŒTone.jsã®Samplerã€ã§ã‚ˆãè¦‹ã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æµç”¨ã—ã¦ã‚‹ã‘ã©ã€ãƒ•ãƒ«ã§å…¨éƒ¨ã¯å¤šã„ã®ã§
      A0, C1, D#1, F#1, A1, C2, ... A7 ãªã©ã€ã‚ã‚‹ç¨‹åº¦é–“å¼•ã„ã¦ã‚ã‚‹ã«ã‚ƒã€‚
      ã“ã‚Œã§å…¨ã‚­ãƒ¼ã‚’ã‚«ãƒãƒ¼ã™ã‚‹ã«ã¯ã€Œè¿‘ã„ã‚µãƒ³ãƒ—ãƒ«ã€ã‚’ä½¿ã£ã¦å†ç”Ÿé€Ÿåº¦ã‚’å¤‰ãˆã¦ãƒ”ãƒƒãƒã‚·ãƒ•ãƒˆã™ã‚‹ã«ã‚ƒã€‚
    */
    const sampleMap = {
      "A0": "A0.mp3",
      "C1": "C1.mp3",
      "Ds1": "Ds1.mp3",
      "Fs1": "Fs1.mp3",
      "A1": "A1.mp3",
      "C2": "C2.mp3",
      "Ds2": "Ds2.mp3",
      "Fs2": "Fs2.mp3",
      "A2": "A2.mp3",
      "C3": "C3.mp3",
      "Ds3": "Ds3.mp3",
      "Fs3": "Fs3.mp3",
      "A3": "A3.mp3",
      "C4": "C4.mp3",
      "Ds4": "Ds4.mp3",
      "Fs4": "Fs4.mp3",
      "A4": "A4.mp3",
      "C5": "C5.mp3",
      "Ds5": "Ds5.mp3",
      "Fs5": "Fs5.mp3",
      "A5": "A5.mp3",
      "C6": "C6.mp3",
      "Ds6": "Ds6.mp3",
      "Fs6": "Fs6.mp3",
      "A6": "A6.mp3",
      "C7": "C7.mp3",
      "Ds7": "Ds7.mp3",
      "Fs7": "Fs7.mp3",
      "A7": "A7.mp3",
    };
    // ä¸Šè¨˜ã®ã‚­ãƒ¼(A0, C1, Ds1...)ã‚’ãƒãƒ¼ãƒˆç•ªå·ã«å¤‰æ›ã—ãŸã„ã®ã§è¡¨ã‚’ä½œã‚‹ã«ã‚ƒ
    // ä¾‹: A0 = 21, C1=24, Ds1=27, Fs1=30... A7=105
    // ä¸‹ã§ä¸€æ‹¬ã§ä½œã‚‹ã‹ã‚‰ã€ã¨ã‚Šã‚ãˆãšãƒãƒƒãƒ—ã ã‘ç”¨æ„

    // ã¾ã¨ã‚ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å…ƒURL
    const baseUrl = "https://tonejs.github.io/audio/salamander/";

    // â˜… AudioWorkletProcessorã®å®Ÿè£…ã‚’æ–‡å­—åˆ—ã§ç”¨æ„ã™ã‚‹ (æœ¬æ¥ã¯åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ãŒç†æƒ³ã ã«ã‚ƒ)
    const workletCode = `
      class MultiSampleProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          // { noteNumber: { sampleData: Float32Array, rate: number }, ... }
          // ãŸã ã—å®Ÿéš›ã¯è¤‡æ•°ã‚µãƒ³ãƒ—ãƒ«ã‚’ä½¿ã„åˆ†ã‘ã‚‹ã«ã‚ƒ(è¿‘ã„ã‚­ãƒ¼ã‚’é¸ã¶)
          this.samples = {};  // noteNumber -> Float32Array
          this.voices = {};   // ç¾åœ¨å†ç”Ÿä¸­ã®ãƒœã‚¤ã‚¹

          this.port.onmessage = (e) => {
            const msg = e.data;
            if (msg.type === "loadedSamples") {
              // msg.data => { noteNumber: Float32Array, ... }
              this.samples = msg.samples;
            } else if (msg.type === "noteOn") {
              const { noteNumber, velocity, nearestNote } = msg;
              // ãƒœã‚¤ã‚¹ä½œæˆ
              // position=0, sample= this.samples[nearestNote], playbackRate = freqRatio
              this.voices[noteNumber] = {
                position: 0,
                sampleData: this.samples[nearestNote],
                playbackRate: Math.pow(2, (noteNumber - nearestNote) / 12),
                velocity: velocity / 127,
              };
            } else if (msg.type === "noteOff") {
              delete this.voices[msg.noteNumber];
            }
          };
        }

        process(inputs, outputs, parameters) {
          const output = outputs[0];
          const channelData = output[0];

          channelData.fill(0);

          // ã‚µãƒ³ãƒ—ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ãªã„ãªã‚‰ç„¡éŸ³
          if (!this.samples || Object.keys(this.samples).length === 0) {
            return true;
          }

          for (let i = 0; i < channelData.length; i++) {
            let out = 0;
            for (const noteNumber in this.voices) {
              const v = this.voices[noteNumber];
              const buf = v.sampleData;
              if (!buf) continue;

              const idx = v.position;
              const idxInt = Math.floor(idx);
              const idxFrac = idx - idxInt;

              // å†ç”Ÿçµ‚äº†ãƒã‚§ãƒƒã‚¯
              if (idxInt >= buf.length - 1) {
                // çµ‚ã‚ã£ãŸã‚‰å‰Šé™¤
                delete this.voices[noteNumber];
                continue;
              }

              // ç·šå½¢è£œé–“(å·¦ã‚µãƒ³ãƒ—ãƒ«, å³ã‚µãƒ³ãƒ—ãƒ«)
              const s1 = buf[idxInt];
              const s2 = buf[idxInt + 1] || 0;
              const sampleVal = s1 + (s2 - s1) * idxFrac;

              out += sampleVal * v.velocity;

              // å†ç”Ÿé€Ÿåº¦ã«å¿œã˜ã¦é€²ã‚ã‚‹
              v.position += v.playbackRate;
            }
            channelData[i] = out * 0.5; // å…¨ä½“éŸ³é‡å°‘ã—ä¸‹ã’
          }

          return true;
        }
      }

      registerProcessor('multi-sample-processor', MultiSampleProcessor);
    `;

    // ãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œã« { noteNumber: Float32Array } ã‚’ä½œã‚‹ãŸã‚ã®å¤‰æ•°
    let audioCtx;
    let sampleNode;
    let sampleGain;

    // MIDIé–‹å§‹
    async function startMIDI() {
      const midiAccess = await navigator.requestMIDIAccess();
      for (let input of midiAccess.inputs.values()) {
        input.onmidimessage = (msg) => {
          const [status, data1, data2] = msg.data;
          const command = status & 0xf0;
          if (command === 0x90 && data2 > 0) {
            // NoteOn
            noteOn(data1, data2);
          } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
            // NoteOff
            noteOff(data1);
          }
        };
      }
    }

    // NoteOn
    function noteOn(noteNumber, velocity) {
      // è¿‘ã„ã‚µãƒ³ãƒ—ãƒ«(= æœ€ã‚‚è¿‘ã„key)ã‚’æ¢ã™
      const nearestSampleNote = findNearestSample(noteNumber);
      sampleNode.port.postMessage({
        type: "noteOn",
        noteNumber,
        velocity,
        nearestNote: nearestSampleNote
      });
    }

    // NoteOff
    function noteOff(noteNumber) {
      sampleNode.port.postMessage({
        type: "noteOff",
        noteNumber
      });
    }

    // äº‹å‰ã«ä½œã£ã¦ãŠã: sampleNoteMap (ä¾‹: { 21: "A0.mp3", 24: "C1.mp3", ... })
    let sampleNoteMap = {};
    let sortedSampleNotes = [];

    // è¿‘ã„ã‚µãƒ³ãƒ—ãƒ«ã‚’æ¢ã™é–¢æ•°
    function findNearestSample(midiNote) {
      // ä¾‹: sortedSampleNotes = [21, 24, 27, 30, 33, ...] ã¿ãŸã„ãªé…åˆ—
      let nearest = sortedSampleNotes[0];
      let minDist = Infinity;
      for (const sn of sortedSampleNotes) {
        const dist = Math.abs(sn - midiNote);
        if (dist < minDist) {
          minDist = dist;
          nearest = sn;
        }
      }
      return nearest;
    }

    // ã‚µãƒ³ãƒ—ãƒ«è¤‡æ•°ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ decodeAudioData â†’ Float32ArrayåŒ–
    async function loadAllSamples() {
      const samples = {};
      // Object.keys(sampleNoteMap) => [ "21", "24", "27", ... ]
      const noteNumbers = Object.keys(sampleNoteMap).map(n => parseInt(n));
      for (let nn of noteNumbers) {
        const url = sampleNoteMap[nn]; // å®Œå…¨URL
        // fetch & decode
        const resp = await fetch(url);
        const buf = await resp.arrayBuffer();
        const audioBuf = await audioCtx.decodeAudioData(buf);
        // ãƒ¢ãƒãƒ©ãƒ«ã§ã„ã„ã‹ã‚‰ Lãƒãƒ£ãƒãƒ«å–ã‚‹
        const chData = audioBuf.getChannelData(0);
        samples[nn] = chData;
      }
      return samples;
    }

    async function startAudioWorklet() {
      // latencyHint: "interactive" ã§AudioContextã‚’ä½œã‚‹ã«ã‚ƒ
      audioCtx = new AudioContext({ latencyHint: 'interactive' });
      // AudioWorkletã‚’ç™»éŒ²
      await audioCtx.audioWorklet.addModule(
        URL.createObjectURL(new Blob([workletCode], {type: 'application/javascript'}))
      );
      // Nodeä½œæˆ
      sampleNode = new AudioWorkletNode(audioCtx, 'multi-sample-processor');

      // ãƒã‚¹ã‚¿ãƒ¼ã‚²ã‚¤ãƒ³
      sampleGain = audioCtx.createGain();
      sampleGain.gain.value = 1.0; // å…¨éŸ³é‡
      sampleNode.connect(sampleGain).connect(audioCtx.destination);

      // å…¨ã‚µãƒ³ãƒ—ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦Dictionaryä½œæˆ
      const loaded = await loadAllSamples();
      // AudioWorkletNodeã«ã€ŒloadedSamplesã€ã§ã¾ã¨ã‚ã¦é€ã‚‹
      sampleNode.port.postMessage({
        type: "loadedSamples",
        samples: loaded
      });
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒœã‚¿ãƒ³æŠ¼ã—ãŸã‚‰èµ·å‹•
    document.getElementById('startBtn').addEventListener('click', async () => {
      // 1) sampleNoteMap ã‚’ä½œã‚‹ (ã‚­ãƒ¼æ–‡å­—åˆ—â†’noteNumber)
      setupSampleMap();
      // 2) AudioWorkletèµ·å‹• & ã‚µãƒ³ãƒ—ãƒ«ãƒ­ãƒ¼ãƒ‰
      await startAudioWorklet();
      await audioCtx.resume();
      // 3) MIDIé–‹å§‹
      await startMIDI();
      alert("AudioWorkletã‚µãƒ³ãƒ—ãƒ©ãƒ¼èµ·å‹•ã«ã‚ƒï¼ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å¼¾ã„ã¦ã¿ã¦ã«ã‚ƒï½ğŸ±");
    });

    function setupSampleMap() {
      // sampleMapã¯ { "A0": "A0.mp3", "C1": "C1.mp3", ...}
      // ã“ã‚Œã‚’ noteNumber ã«å¤‰æ›ã—ã€ä¾‹ãˆã° 21 -> "https://tonejs.github.io/audio/salamander/A0.mp3" ã«ã—ãŸã„ã«ã‚ƒ
      for (let key in sampleMap) {
        // keyã¯"A0","C1","Ds1"ãªã©ã€‚ã¾ãšnoteNumberã«å¤‰æ›ã™ã‚‹
        const nn = noteNameToMidi(key);
        const file = sampleMap[key];
        // ãƒ•ãƒ«URL
        const fullUrl = baseUrl + file;
        sampleNoteMap[nn] = fullUrl;
      }
      // sortedSampleNotes = [21,24,27,30,...]ã®ã‚ˆã†ã«ã‚½ãƒ¼ãƒˆã—ã¨ã
      sortedSampleNotes = Object.keys(sampleNoteMap).map(n => parseInt(n)).sort((a,b)=>a-b);
    }

    // "A0"ãªã©â†’ãƒãƒ¼ãƒˆç•ªå·
    function noteNameToMidi(noteName) {
      // ä¾‹: "A0" -> 21
      // "C4" -> 60, "Ds4" -> 63, ...
      const table = {
        "C": 0, "C#":1, "Db":1, "D":2, "D#":3, "Eb":3, "E":4, "F":5, "F#":6, "Gb":6,
        "G":7, "G#":8, "Ab":8, "A":9, "A#":10, "Bb":10, "B":11
      };
      // noteNameã‚’ãƒ‘ãƒ¼ã‚¹: "A0" => note="A", octave="0", or "Ds4" => note="Ds", octave="4"
      // 2æ–‡å­—ã‹3æ–‡å­—ã‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã‚ã‚‹ã‹ã‚‰ã¡ã‚‡ã£ã¨å·¥å¤«
      let match = noteName.match(/^([A-G][#s]?)(\d+)/);
      if (!match) { return 60; } // fallback C4
      let noteStr = match[1].replace("s", "#"); // "Ds" -> "D#"
      let octave = parseInt(match[2], 10);
      let semitone = table[noteStr] ?? 0;
      return semitone + (octave + 1) * 12;
    }
  </script>
</body>
</html>
