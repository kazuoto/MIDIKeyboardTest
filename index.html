<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AudioWorklet Multi-Sample Piano-ish + Reverb</title>
</head>
<body>
  <h1>AudioWorklet„Åß„Éî„Ç¢„Éé„Çµ„É≥„Éó„É´ + „É™„Éê„Éº„Éñ„Å´„ÇÉ</h1>
  <button id="startBtn">„Ç™„Éº„Éá„Ç£„Ç™ÔºÜMIDIÈñãÂßã„Å´„ÇÉ</button>

  <script>
    /* 
      ‚óÜ 1) „Éû„É´„ÉÅ„Çµ„É≥„Éó„É´ÔºàSalamander Piano „ÅÆ‰∏ÄÈÉ®„Ç≠„ÉºÔºâ
      ‚óÜ 2) AudioWorklet„Åß‰ΩéÈÅÖÂª∂ÂÜçÁîü
      ‚óÜ 3) „É™„Éê„Éº„Éñ(ConvolverNode)ËøΩÂä†
      ‚óÜ 4) „Éû„Çπ„Çø„Éº„Ç≤„Ç§„É≥‰∏ä„Åí
    */
    
    const sampleMap = {
      "A0": "A0.mp3",
      "C1": "C1.mp3",
      "Ds1": "Ds1.mp3",
      "Fs1": "Fs1.mp3",
      "A1": "A1.mp3",
      "C2": "C2.mp3",
      "Ds2": "Ds2.mp3",
      "Fs2": "Fs2.mp3",
      "A2": "A2.mp3",
      "C3": "C3.mp3",
      "Ds3": "Ds3.mp3",
      "Fs3": "Fs3.mp3",
      "A3": "A3.mp3",
      "C4": "C4.mp3",
      "Ds4": "Ds4.mp3",
      "Fs4": "Fs4.mp3",
      "A4": "A4.mp3",
      "C5": "C5.mp3",
      "Ds5": "Ds5.mp3",
      "Fs5": "Fs5.mp3",
      "A5": "A5.mp3",
      "C6": "C6.mp3",
      "Ds6": "Ds6.mp3",
      "Fs6": "Fs6.mp3",
      "A6": "A6.mp3",
      "C7": "C7.mp3",
      "Ds7": "Ds7.mp3",
      "Fs7": "Fs7.mp3",
      "A7": "A7.mp3",
    };
    const baseUrl = "https://tonejs.github.io/audio/salamander/";

    // ËªΩ„ÇÅ„ÅÆ„É™„Éê„Éº„ÉñÁî®„Ç§„É≥„Éë„É´„ÇπÂøúÁ≠î(IR)„Çí„Å©„Åì„Åã„Åã„ÇâÊåÅ„Å£„Å¶„Åè„Çã„Å´„ÇÉ
    // ‰ªäÂõû„ÅØÈÅ©ÂΩì„Å´ "https://cdn.jsdelivr.net/gh/gregtafourneau/ImpulseResponses/SnareRoom.wav" „Åø„Åü„ÅÑ„Å™„ÅÆ„Çí‰æãÁ§∫„Åô„Çã„Å´„ÇÉ
    // (ÂÆüÈöõ„Å´ËÅ¥„ÅçÊØî„Åπ„Å¶„ÅäÂ•Ω„Åø„ÅÆIR„ÇíÊé¢„Åó„Å¶„Åø„Å¶„Å´„ÇÉ)
    const reverbImpulseURL = "https://cdn.jsdelivr.net/gh/gregtafourneau/ImpulseResponses/SnareRoom.wav";

    // AudioWorklet„Ç≥„Éº„Éâ(„Éû„É´„ÉÅ„Çµ„É≥„Éó„É´ÂÜçÁîü)„ÅØÂâçÂõû„ÅÆ„ÇÇ„ÅÆ„ÇíË≤º„Çä‰ªò„Åë„Å´„ÇÉ
    const workletCode = `
      class MultiSampleProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          this.samples = {}; 
          this.voices = {}; 

          this.port.onmessage = (e) => {
            const msg = e.data;
            if (msg.type === "loadedSamples") {
              this.samples = msg.samples;
            } else if (msg.type === "noteOn") {
              const { noteNumber, velocity, nearestNote } = msg;
              this.voices[noteNumber] = {
                position: 0,
                sampleData: this.samples[nearestNote],
                playbackRate: Math.pow(2, (noteNumber - nearestNote) / 12),
                velocity: velocity / 127,
              };
            } else if (msg.type === "noteOff") {
              delete this.voices[msg.noteNumber];
            }
          };
        }

        process(inputs, outputs, parameters) {
          const output = outputs[0];
          const channelData = output[0];
          channelData.fill(0);

          if (!this.samples || Object.keys(this.samples).length === 0) {
            return true;
          }

          for (let i = 0; i < channelData.length; i++) {
            let out = 0;
            for (const noteNumber in this.voices) {
              const v = this.voices[noteNumber];
              if (!v.sampleData) continue;
              const buf = v.sampleData;

              const idx = v.position;
              const idxInt = Math.floor(idx);
              const idxFrac = idx - idxInt;

              if (idxInt >= buf.length - 1) {
                delete this.voices[noteNumber];
                continue;
              }

              const s1 = buf[idxInt];
              const s2 = buf[idxInt + 1] || 0;
              const sampleVal = s1 + (s2 - s1) * idxFrac;

              out += sampleVal * v.velocity;

              v.position += v.playbackRate;
            }
            channelData[i] = out * 0.5;
          }

          return true;
        }
      }

      registerProcessor('multi-sample-processor', MultiSampleProcessor);
    `;

    let audioCtx;
    let sampleNode;
    let reverbNode;
    let masterGain;

    let sampleNoteMap = {};
    let sortedSampleNotes = [];

    document.getElementById('startBtn').addEventListener('click', async () => {
      setupSampleMap();                // „Éû„ÉÉ„Éî„É≥„Ç∞
      await startAudioWorklet();       // AudioWorklet
      await audioCtx.resume();         // „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„ÅßËß£Êîæ
      await loadAndSetReverbImpulse(); // „É™„Éê„Éº„ÉñIR„É≠„Éº„Éâ
      await startMIDI();               // MIDI
      alert("Ëµ∑Âãï„Å´„ÇÉÔºÅ„É™„Éê„Éº„Éñ+Èü≥ÈáèUP„Ç¢„É™„ÄÇÂºæ„ÅÑ„Å¶„Åø„Å¶„Å´„ÇÉÔΩûüê±");
    });

    // AudioWorkletËµ∑Âãï & „Çµ„É≥„Éó„É´„É≠„Éº„Éâ
    async function startAudioWorklet() {
      audioCtx = new AudioContext({ latencyHint: "interactive" });
      await audioCtx.audioWorklet.addModule(
        URL.createObjectURL(new Blob([workletCode], {type: 'application/javascript'}))
      );
      sampleNode = new AudioWorkletNode(audioCtx, 'multi-sample-processor');

      // ‚óÜ „Åì„Åì„Åß ConvolverNode („É™„Éê„Éº„Éñ) „Çí‰Ωú„Çã„Å´„ÇÉ
      reverbNode = audioCtx.createConvolver();
      // „Åæ„Å†impulse„ÅØÊú™„É≠„Éº„Éâ„Å™„ÅÆ„ÅßÁ©∫
      // Âæå„Åß loadAndSetReverbImpulse() „ÅßIR„Çí„Çª„ÉÉ„Éà„Åô„Çã„Å´„ÇÉ

      // ‚óÜ „Éû„Çπ„Çø„Éº„Ç≤„Ç§„É≥„Çí„Å°„Çá„Å£„Å®‰∏ä„Åí„Çã(Ââç„ÅØ1.0„Å†„Å£„Åü„ÅÆ„Çí1.5„Å®„Åã„Å´„Åô„Çã)
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 1.5; // Èü≥ÈáèUP

      // Êé•Á∂öÈ†Ü: sampleNode -> reverbNode -> masterGain -> destination
      sampleNode.connect(reverbNode).connect(masterGain).connect(audioCtx.destination);

      // ÂÖ®„Çµ„É≥„Éó„É´„Çí„É≠„Éº„Éâ„Åó„Å¶Worklet„Å´ÈÄÅ„Çã
      const loaded = await loadAllSamples();
      sampleNode.port.postMessage({
        type: "loadedSamples",
        samples: loaded
      });
    }

    // „É™„Éê„Éº„Éñ„Å´‰Ωø„ÅÜImpulseResponse„Çí„É≠„Éº„ÉâÔºÜdecode„Åó„Å¶ConvolverNode„Å´„Çª„ÉÉ„Éà
    async function loadAndSetReverbImpulse() {
      const resp = await fetch(reverbImpulseURL);
      const arrBuf = await resp.arrayBuffer();
      const audioBuf = await audioCtx.decodeAudioData(arrBuf);
      reverbNode.buffer = audioBuf;
      console.log("„É™„Éê„Éº„ÉñIRË™≠„ÅøËæº„ÅøÂÆå‰∫Ü„Å´„ÇÉ:", reverbNode.buffer);
    }

    // MIDIÈñãÂßã
    async function startMIDI() {
      const midiAccess = await navigator.requestMIDIAccess();
      for (let input of midiAccess.inputs.values()) {
        input.onmidimessage = (msg) => {
          const [status, data1, data2] = msg.data;
          const command = status & 0xf0;
          if (command === 0x90 && data2 > 0) {
            noteOn(data1, data2);
          } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
            noteOff(data1);
          }
        };
      }
    }

    function noteOn(noteNumber, velocity) {
      const nearestSampleNote = findNearestSample(noteNumber);
      sampleNode.port.postMessage({
        type: "noteOn",
        noteNumber,
        velocity,
        nearestNote: nearestSampleNote
      });
    }

    function noteOff(noteNumber) {
      sampleNode.port.postMessage({
        type: "noteOff",
        noteNumber
      });
    }

    // ‰ª•‰∏ã„ÅØÂâç„Å®Âêå„Åò: sampleMap‚ÜínoteNumber, „Çµ„É≥„Éó„É´„É≠„Éº„Éâ„Å™„Å©
    function setupSampleMap() {
      for (let key in sampleMap) {
        const nn = noteNameToMidi(key);
        const fullUrl = baseUrl + sampleMap[key];
        sampleNoteMap[nn] = fullUrl;
      }
      sortedSampleNotes = Object.keys(sampleNoteMap).map(n => parseInt(n)).sort((a,b)=>a-b);
    }

    function findNearestSample(midiNote) {
      let nearest = sortedSampleNotes[0];
      let minDist = Infinity;
      for (const sn of sortedSampleNotes) {
        const dist = Math.abs(sn - midiNote);
        if (dist < minDist) {
          minDist = dist;
          nearest = sn;
        }
      }
      return nearest;
    }

    async function loadAllSamples() {
      const samples = {};
      const noteNumbers = Object.keys(sampleNoteMap).map(n => parseInt(n));
      for (let nn of noteNumbers) {
        const url = sampleNoteMap[nn];
        const resp = await fetch(url);
        const buf = await resp.arrayBuffer();
        const audioBuf = await audioCtx.decodeAudioData(buf);
        const chData = audioBuf.getChannelData(0);
        samples[nn] = chData;
      }
      return samples;
    }

    function noteNameToMidi(noteName) {
      const table = {
        "C": 0, "C#":1, "Db":1, "D":2, "D#":3, "Eb":3, "E":4, "F":5, "F#":6, "Gb":6,
        "G":7, "G#":8, "Ab":8, "A":9, "A#":10, "Bb":10, "B":11
      };
      let match = noteName.match(/^([A-G][#s]?)(\d+)/);
      if (!match) return 60; 
      let noteStr = match[1].replace("s", "#");
      let octave = parseInt(match[2], 10);
      let semitone = table[noteStr] ?? 0;
      return semitone + (octave + 1) * 12;
    }
  </script>
</body>
</html>
